import { Response } from "express";
import { PaymentMethod, PaymentStatus } from "@prisma/cli      // Create payment intent with split payment
      const paymentIntent = await stripeService.createPaymentIntentWithSplit({
        id: booking.id,
        totalPrice: totalAmount,
        currency: booking.currency.toLowerCase(),
        propertyPrice: propertyAmount,
        serviceFee: serviceFeeAmount,
        platformCommission: platformCommission,
        realtorPayout: realtorPayout,
        stripeAccountId: booking.property.realtor.stripeAccountId,
        gatewayFee: gatewayFee,
        metadata: {
          bookingId: booking.id,
          guestId: booking.guestId,
          propertyId: booking.propertyId,
          propertyTitle: booking.property.title,
        },
      });{ prisma } from "@/config/database";
import { AuthenticatedRequest } from "@/types";
import { AppError, asyncHandler } from "@/middleware/errorHandler";
import { config } from "@/config";
import { stripeService } from "@/services/stripe";
import { paystackService } from "@/services/paystack";
import { sendPaymentReceipt, sendBookingConfirmation } from "@/services/email";
import { PDFService } from "@/services/pdf";

/**
 * @desc    Create payment intent for Stripe (international clients)
 * @route   POST /api/payments/create-stripe-intent
 * @access  Private
 */
export const createStripePaymentIntent = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { bookingId } = req.body;

    if (!bookingId) {
      throw new AppError("Booking ID is required", 400);
    }

    // Get booking details with realtor info for platform fee calculation
    const booking = await prisma.booking.findUnique({
      where: { id: bookingId },
      include: {
        property: {
          include: {
            realtor: {
              select: {
                id: true,
              email: true,
              firstName: true,
              lastName: true,
                
                stripeAccountId: true,
                commissionRate: true,
              },
            },
          },
        },
        guest: {
          select: {
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        payment: true,
      },
    });

    if (!booking) {
      throw new AppError("Booking not found", 404);
    }

    // Check if user owns the booking
    if (booking.guestId !== req.user!.id) {
      throw new AppError("Not authorized to pay for this booking", 403);
    }

    // Check if booking is payable
    if (booking.status !== "PENDING") {
      throw new AppError("Booking is not in a payable state", 400);
    }

    // Check if payment already exists
    if (booking.payment) {
      throw new AppError("Payment already exists for this booking", 400);
    }

    // Ensure realtor has Stripe Connect account
    if (!booking.property.realtor.stripeAccountId) {
      throw new AppError(
        "Property owner hasn't set up payment processing",
        400
      );
    }

    try {
      // Calculate platform fee and breakdowns
      const commissionRate =
        Number(booking.property.realtor.commissionRate) || 0.05; // Default 5%
      const totalAmount = Number(booking.totalPrice);
      const platformCommission = Math.round(totalAmount * commissionRate);
      const serviceFeeAmount = Number(booking.serviceFee);
      const gatewayFee = Math.round(totalAmount * 0.029 + 0.3); // Stripe fee
      const propertyAmount = Number(booking.propertyPrice);
      const realtorPayout = propertyAmount - platformCommission;
      const platformNet = platformCommission - gatewayFee;

      // Create payment intent with split payment
      const paymentIntent = await stripeService.createPaymentIntentWithSplit(
        totalAmount,
        booking.currency.toLowerCase(),
        booking.property.realtor.stripeAccountId,
        platformCommission,
        {
          bookingId: booking.id,
          guestId: booking.guestId,
          realtorId: booking.property.realtor.id,
          propertyTitle: booking.property.title,
        }
      );

      // Create payment record
      const payment = await prisma.payment.create({
        data: {
          amount: totalAmount,
          propertyAmount,
          serviceFeeAmount,
          platformCommission,
          realtorPayout,
          gatewayFee,
          platformNet,
          currency: booking.currency,
          status: PaymentStatus.PENDING,
          method: PaymentMethod.STRIPE,
          stripePaymentIntentId: paymentIntent.id,
          bookingId: booking.id,
          userId: req.user!.id,
          metadata: {
            stripeClientSecret: paymentIntent.client_secret,
            connectedAccountId: booking.property.realtor.stripeAccountId,
          },
        },
      });

      res.json({
        success: true,
        message: "Stripe payment intent created successfully",
        data: {
          payment,
          clientSecret: paymentIntent.client_secret,
          platformCommission,
        },
      });
    } catch (error: any) {
      throw new AppError(
        error.message || "Failed to create payment intent",
        500
      );
    }
  }
);

/**
 * @desc    Initialize Paystack split payment (African clients)
 * @route   POST /api/payments/initialize-paystack
 * @access  Private
 */
export const initializePaystackPayment = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { bookingId } = req.body;

    if (!bookingId) {
      throw new AppError("Booking ID is required", 400);
    }

    // Get booking details with realtor info
    const booking = await prisma.booking.findUnique({
      where: { id: bookingId },
      include: {
        property: {
          include: {
            realtor: {
              select: {
                id: true,
              email: true,
              firstName: true,
              lastName: true,
                
                paystackSubAccountId: true,
                commissionRate: true,
              },
            },
          },
        },
        guest: {
          select: {
            email: true,
            firstName: true,
            lastName: true,
          },
        },
        payment: true,
      },
    });

    if (!booking) {
      throw new AppError("Booking not found", 404);
    }

    // Check if user owns the booking
    if (booking.guestId !== req.user!.id) {
      throw new AppError("Not authorized to pay for this booking", 403);
    }

    // Check if booking is payable
    if (booking.status !== "PENDING") {
      throw new AppError("Booking is not in a payable state", 400);
    }

    // Check if payment already exists
    if (booking.payment) {
      throw new AppError("Payment already exists for this booking", 400);
    }

    // Ensure realtor has Paystack subaccount
    if (!booking.property.realtor.paystackSubAccountId) {
      throw new AppError(
        "Property owner hasn't set up payment processing",
        400
      );
    }

    try {
      // Calculate platform fee and breakdowns
      const commissionRate =
        Number(booking.property.realtor.commissionRate) || 0.05; // Default 5%
      const totalAmount = Number(booking.totalPrice);
      const platformCommission = Math.round(totalAmount * commissionRate);
      const serviceFeeAmount = Number(booking.serviceFee);
      const gatewayFee = Math.round(totalAmount * 0.029 + 0.3); // Gateway fee
      const propertyAmount = Number(booking.propertyPrice);
      const realtorPayout = propertyAmount - platformCommission;
      const platformNet = platformCommission - gatewayFee;

      // Initialize split payment
      const paymentData = await paystackService.initializeSplitPayment(
        totalAmount,
        booking.guest.email,
        booking.property.realtor.paystackSubAccountId,
        platformCommission,
        {
          bookingId: booking.id,
          guestId: booking.guestId,
          realtorId: booking.property.realtor.id,
          propertyTitle: booking.property.title,
        }
      );

      // Create payment record
      const payment = await prisma.payment.create({
        data: {
          amount: totalAmount,
          propertyAmount,
          serviceFeeAmount,
          platformCommission,
          realtorPayout,
          gatewayFee,
          platformNet,
          currency: booking.currency,
          status: PaymentStatus.PENDING,
          method: PaymentMethod.PAYSTACK,
          paystackReference: paymentData.reference,
          bookingId: booking.id,
          userId: req.user!.id,
          metadata: {
            paystackAccessCode: paymentData.access_code,
            subAccountId: booking.property.realtor.paystackSubAccountId,
          },
        },
      });

      res.json({
        success: true,
        message: "Paystack payment initialized successfully",
        data: {
          payment,
          authorizationUrl: paymentData.authorization_url,
          accessCode: paymentData.access_code,
          reference: paymentData.reference,
          platformCommission,
        },
      });
    } catch (error: any) {
      throw new AppError(error.message || "Failed to initialize payment", 500);
    }
  }
);

/**
 * @desc    Verify Paystack payment
 * @route   POST /api/payments/verify-paystack
 * @access  Private
 */
export const verifyPaystackPayment = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { reference } = req.body;

    if (!reference) {
      throw new AppError("Payment reference is required", 400);
    }

    // Find payment record
    const payment = await prisma.payment.findFirst({
      where: { paystackReference: reference },
      include: {
        booking: {
          include: {
            property: {
              include: {
                realtor: true,
              },
            },
            guest: true,
          },
        },
      },
    });

    if (!payment) {
      throw new AppError("Payment not found", 404);
    }

    // Check if user owns the payment
    if (payment.userId !== req.user!.id) {
      throw new AppError("Not authorized to verify this payment", 403);
    }

    try {
      // Verify payment with Paystack
      const verification = await paystackService.verifyTransaction(reference);

      if (verification.status === "success") {
        // Update payment and booking status
        const updatedPayment = await prisma.payment.update({
          where: { id: payment.id },
          data: {
            status: PaymentStatus.COMPLETED,
            metadata: {
              ...(payment.metadata as object),
              verificationData: verification,
            },
          },
        });

        await prisma.booking.update({
          where: { id: payment.bookingId },
          data: { status: "CONFIRMED" },
        });

        // Send confirmation emails and receipt
        try {
          // Send booking confirmation to guest
          await sendBookingConfirmation(
            payment.booking.guest.email,
            payment.booking,
            payment.booking.property,
            payment.booking.property.realtor
          );

          // Generate and send receipt PDF
          const receiptPDF = await PDFService.generateBookingReceipt(
            payment.booking,
            payment.booking.property,
            payment.booking.guest,
            updatedPayment
          );

          const pdfAttachment = {
            filename: `receipt-${payment.booking.id}.pdf`,
            content: receiptPDF,
            contentType: "application/pdf",
          };

          await sendPaymentReceipt(
            payment.booking.guest.email,
            payment.booking,
            updatedPayment,
            payment.booking.property,
            pdfAttachment
          );
        } catch (emailError) {
          console.error("Failed to send confirmation emails:", emailError);
          // Don't throw - payment is successful even if emails fail
        }

        res.json({
          success: true,
          message: "Payment verified successfully",
          data: updatedPayment,
        });
      } else {
        // Update payment status to failed
        await prisma.payment.update({
          where: { id: payment.id },
          data: { status: PaymentStatus.FAILED },
        });

        throw new AppError("Payment verification failed", 400);
      }
    } catch (error: any) {
      throw new AppError(error.message || "Failed to verify payment", 500);
    }
  }
);

/**
 * @desc    Get payment details
 * @route   GET /api/payments/:id
 * @access  Private
 */
export const getPayment = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { id } = req.params;

    const payment = await prisma.payment.findUnique({
      where: { id },
      include: {
        booking: {
          include: {
            property: {
              select: {
                title: true,
                realtorId: true,
              },
            },
          },
        },
      },
    });

    if (!payment) {
      throw new AppError("Payment not found", 404);
    }

    // Check authorization
    const isOwner = payment.userId === req.user!.id;
    const isHost = payment.booking.property.realtorId === req.user!.id;
    const isAdmin = req.user!.role === "ADMIN";

    if (!isOwner && !isHost && !isAdmin) {
      throw new AppError("Not authorized to view this payment", 403);
    }

    res.json({
      success: true,
      message: "Payment retrieved successfully",
      data: payment,
    });
  }
);

/**
 * @desc    Process refund
 * @route   POST /api/payments/:id/refund
 * @access  Private
 */
export const processRefund = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { id } = req.params;
    const { reason, amount } = req.body;

    const payment = await prisma.payment.findUnique({
      where: { id },
      include: {
        booking: {
          include: {
            property: {
              include: {
                realtor: true,
              },
            },
            guest: true,
          },
        },
      },
    });

    if (!payment) {
      throw new AppError("Payment not found", 404);
    }

    // Check authorization (only booking owner or admin can request refund)
    const isOwner = payment.userId === req.user!.id;
    const isAdmin = req.user!.role === "ADMIN";

    if (!isOwner && !isAdmin) {
      throw new AppError("Not authorized to refund this payment", 403);
    }

    // Check if payment is refundable
    if (payment.status !== PaymentStatus.COMPLETED) {
      throw new AppError("Only completed payments can be refunded", 400);
    }

    // Check if booking is refundable
    if (!payment.booking.isRefundable) {
      throw new AppError("This booking is not refundable", 400);
    }

    // Check refund deadline
    if (
      payment.booking.refundDeadline &&
      new Date() > payment.booking.refundDeadline
    ) {
      throw new AppError("Refund deadline has passed", 400);
    }

    const refundAmount = amount || Number(payment.amount);

    try {
      if (payment.method === PaymentMethod.STRIPE) {
        // Process Stripe refund
        const stripeRefund = await stripeService.processRefund(
          payment.stripePaymentIntentId!,
          refundAmount,
          reason || "Customer requested refund"
        );

        // Create refund record
        await prisma.refund.create({
          data: {
            amount: refundAmount,
            currency: payment.currency,
            reason: reason || "Customer requested refund",
            status: PaymentStatus.COMPLETED,
            method: PaymentMethod.STRIPE,
            stripeRefundId: stripeRefund.id,
            bookingId: payment.bookingId,
            paymentId: payment.id,
            adminApproved: true,
            adminApprovedAt: new Date(),
            processedAt: new Date(),
          },
        });

        // Update payment status to refunded
        const updatedPayment = await prisma.payment.update({
          where: { id },
          data: {
            status: PaymentStatus.REFUNDED,
          },
        });
      } else if (payment.method === PaymentMethod.PAYSTACK) {
        // Process Paystack refund
        const paystackRefund = await paystackService.processRefund(
          payment.paystackReference!,
          refundAmount
        );

        // Create refund record
        await prisma.refund.create({
          data: {
            amount: refundAmount,
            currency: payment.currency,
            reason: reason || "Customer requested refund",
            status: PaymentStatus.COMPLETED,
            method: PaymentMethod.PAYSTACK,
            paystackRefundId: paystackRefund.id,
            bookingId: payment.bookingId,
            paymentId: payment.id,
            adminApproved: true,
            adminApprovedAt: new Date(),
            processedAt: new Date(),
          },
        });

        // Update payment status to refunded
        const updatedPayment = await prisma.payment.update({
          where: { id },
          data: {
            status: PaymentStatus.REFUNDED,
          },
        });
      }

      // Update booking status
      await prisma.booking.update({
        where: { id: payment.bookingId },
        data: { status: "REFUNDED" },
      });

      res.json({
        success: true,
        message: "Refund processed successfully",
        data: {
          refundAmount,
          reason,
          refundStatus: "completed",
        },
      });
    } catch (error: any) {
      throw new AppError(error.message || "Failed to process refund", 500);
    }
  }
);

/**
 * @desc    Get user's payments
 * @route   GET /api/payments
 * @access  Private
 */
export const getUserPayments = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { page = 1, limit = 10, status } = req.query;

    const whereClause: any = {
      userId: req.user!.id,
    };

    if (status) {
      whereClause.status = status;
    }

    const payments = await prisma.payment.findMany({
      where: whereClause,
      include: {
        booking: {
          include: {
            property: {
              select: {
                title: true,
                city: true,
                images: true,
              },
            },
          },
        },
      },
      orderBy: {
        createdAt: "desc",
      },
      skip: (Number(page) - 1) * Number(limit),
      take: Number(limit),
    });

    const totalPayments = await prisma.payment.count({
      where: whereClause,
    });

    res.json({
      success: true,
      message: "Payments retrieved successfully",
      data: {
        payments,
        pagination: {
          currentPage: Number(page),
          totalPages: Math.ceil(totalPayments / Number(limit)),
          totalItems: totalPayments,
          itemsPerPage: Number(limit),
        },
      },
    });
  }
);

/**
 * @desc    Generate payment receipt PDF
 * @route   GET /api/payments/:id/receipt
 * @access  Private
 */
export const generatePaymentReceipt = asyncHandler(
  async (req: AuthenticatedRequest, res: Response) => {
    const { id } = req.params;

    const payment = await prisma.payment.findUnique({
      where: { id },
      include: {
        booking: {
          include: {
            property: true,
            guest: true,
          },
        },
      },
    });

    if (!payment) {
      throw new AppError("Payment not found", 404);
    }

    // Check authorization
    const isOwner = payment.userId === req.user!.id;
    const isHost = payment.booking.property.realtorId === req.user!.id;
    const isAdmin = req.user!.role === "ADMIN";

    if (!isOwner && !isHost && !isAdmin) {
      throw new AppError("Not authorized to view this payment", 403);
    }

    if (payment.status !== PaymentStatus.COMPLETED) {
      throw new AppError(
        "Receipt is only available for completed payments",
        400
      );
    }

    try {
      const pdfBuffer = await PDFService.generateBookingReceipt(
        payment.booking,
        payment.booking.property,
        payment.booking.guest,
        payment
      );

      res.setHeader("Content-Type", "application/pdf");
      res.setHeader(
        "Content-Disposition",
        `attachment; filename="receipt-${payment.booking.id}.pdf"`
      );
      res.send(pdfBuffer);
    } catch (error: any) {
      throw new AppError(error.message || "Failed to generate receipt", 500);
    }
  }
);

export const paymentController = {
  createStripePaymentIntent,
  initializePaystackPayment,
  verifyPaystackPayment,
  getPayment,
  processRefund,
  getUserPayments,
  generatePaymentReceipt,
};
